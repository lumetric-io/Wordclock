<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wordclock Admin</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .spinner {
      width: 1rem;
      height: 1rem;
      border: 2px solid #cbd5e1;
      border-top-color: #1f2937;
      border-radius: 9999px;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
    }
    .spinner.hidden {
      display: none;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans">
  <div class="max-w-xl mx-auto p-4">
    <header class="flex items-center justify-between mb-6">
      <h1 class="text-3xl font-bold">üîê Admin</h1>
      <div class="flex items-center gap-4">
        <a href="/dashboard.html" class="text-sm text-blue-600 hover:underline">Back to dashboard</a>
      </div>
    </header>

    <section class="bg-white p-4 rounded-2xl shadow">
      <p class="text-sm text-gray-700">This page is protected with a manufacturer password.</p>
      <ul class="list-disc pl-6 mt-3 text-sm text-gray-700">
        <li>Use this page for production/service actions.</li>
        <li>Critical endpoints remain accessible only with this password.</li>
      </ul>
      <div class="mt-4 grid grid-cols-2 gap-2">
        <a class="py-2 rounded bg-yellow-500 text-white text-center hover:bg-yellow-600" href="/restart">üîÅ Restart</a>
        <a class="py-2 rounded bg-blue-500 text-white text-center hover:bg-blue-600" href="/resetwifi">üì∂ Reset WiFi</a>
        <a class="py-2 rounded bg-purple-500 text-white text-center hover:bg-purple-600" href="/startSequence">‚ú® Start Sequence</a>
        <button class="py-2 rounded bg-gray-700 text-white text-center hover:bg-gray-800 relative" id="updateBtnAdm">
          <span id="updateBtnLabel">‚¨ÜÔ∏è Update</span>
          <span id="updateBtnMsg" class="block text-xs text-gray-200 mt-1"></span>
        </button>
        <a class="py-2 rounded bg-gray-200 text-gray-800 text-center hover:bg-gray-300" href="/update.html" id="updatePageLink">üß∞ Update page</a>
      </div>

      <div class="mt-4 bg-gray-50 border border-gray-200 rounded-xl p-4" id="releaseChannelSection">
        <h2 class="text-lg font-semibold mb-2">Release channel</h2>
        <div class="space-y-1 mb-2">
          <label class="inline-flex items-center space-x-2">
            <input type="radio" name="updateChannelAdmin" value="stable" class="form-radio">
            <span>Stable (recommended)</span>
          </label><br>
          <label class="inline-flex items-center space-x-2">
            <input type="radio" name="updateChannelAdmin" value="early" class="form-radio">
            <span>Early (experimental)</span>
          </label><br>
          <label class="inline-flex items-center space-x-2 text-red-600">
            <input type="radio" name="updateChannelAdmin" value="develop" class="form-radio">
            <span>Develop (kan de klok onbruikbaar maken; herstel niet gegarandeerd)</span>
          </label>
          <p id="updateChannelStatusAdmin" class="text-xs text-gray-500">Default: stable. Early/Develop kunnen instabiel zijn.</p>
        </div>
      </div>

      <div class="mt-4" id="syncUiSection">
        <button id="syncUiBtn" class="py-2 px-3 rounded bg-indigo-600 text-white hover:bg-indigo-700">üóÇÔ∏è Sync UI files</button>
        <p id="syncUiMsg" class="text-xs text-gray-600 mt-2"></p>
      </div>

      <div class="mt-2">
        <a href="/logs.html" class="inline-block py-2 px-3 rounded bg-gray-200 text-gray-700 hover:bg-gray-300 text-sm">üìÅ View logs</a>
      </div>

      <div class="mt-6 bg-gray-50 border border-gray-200 rounded-xl p-4">
        <h2 class="text-xl font-semibold mb-3">Log Settings</h2>
        <div class="space-y-4">
          <div>
            <label for="logRetention" class="block text-sm font-medium text-gray-700">Retention (days)</label>
            <div class="flex items-center gap-3 mt-1">
              <input type="range" id="logRetention" min="1" max="10" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
              <span id="logRetentionVal" class="text-sm font-mono bg-white px-2 py-1 rounded border min-w-[2.5rem] text-center">1</span>
            </div>
            <p class="text-xs text-gray-500 mt-1">Number of days to keep log files (1-10). Default is 1.</p>
          </div>
          <div class="flex items-center justify-between">
            <label for="logDeleteOnBoot" class="text-sm font-medium text-gray-700">Clear logs on restart</label>
            <input type="checkbox" id="logDeleteOnBoot" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
          </div>
          <div class="pt-2 border-t border-gray-200">
            <label for="logLevel" class="block text-sm font-medium text-gray-700 mb-1">Log Level</label>
            <select id="logLevel" class="w-full border rounded p-2 text-sm bg-white">
              <option value="0">DEBUG</option>
              <option value="1">INFO</option>
              <option value="2">WARN</option>
              <option value="3">ERROR</option>
            </select>
          </div>
          <button id="saveLogSettings" class="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
            Save Log Settings
          </button>
          <p id="logSettingsStatus" class="text-xs text-center mt-2"></p>
        </div>
      </div>

      <div class="mt-4">
        <button id="factoryBtn" class="py-2 px-3 rounded bg-red-600 text-white hover:bg-red-700">üß® Factory reset</button>
        <p id="factoryMsg" class="text-xs text-gray-600 mt-2"></p>
      </div>

      <div class="mt-6 flex items-center gap-3">
        <label for="sellMode" class="text-sm">Sell mode (show 10:47)</label>
        <input type="checkbox" id="sellMode" class="h-4 w-4">
      </div>

      <div class="mt-6">
        <label for="gridVariant" class="block text-sm font-semibold mb-1">Grid layout</label>
        <select id="gridVariant" class="w-full border rounded p-2 text-sm"></select>
        <p class="text-xs text-gray-500 mt-1">Notatie: <em>Naam [TAAL VERSIE]</em>, bijvoorbeeld <em>Nederlands V2 [NL V2]</em>.</p>
        <p id="gridVariantStatus" class="text-xs text-gray-600 mt-2"></p>
      </div>

      <h2 class="text-xl font-semibold mt-6 mb-2">Color</h2>
      <input type="color" id="adminColorPicker" class="w-full h-12 rounded p-0 border-2" />

      <h2 class="text-xl font-semibold mt-6 mb-2">Upload firmware</h2>
      <form action="/uploadFirmware" method="POST" enctype="multipart/form-data" class="space-y-2">
        <input type="file" name="firmwareFile" accept=".bin" required class="block w-full text-sm text-gray-700" />
        <button type="submit" class="py-2 px-3 rounded bg-gray-700 text-white hover:bg-gray-800">Upload</button>
      </form>
      <p id="updateStatus" class="text-xs text-gray-600 mt-2"></p>
      <span id="updateSpinnerAdm" class="spinner hidden" aria-label="Update in progress"></span>

      <h2 class="text-xl font-semibold mt-6 mb-2">Upload UI (LittleFS)</h2>
      <form action="/uploadFs" method="POST" enctype="multipart/form-data" class="space-y-2">
        <input type="file" name="filesystemFile" accept=".bin" required class="block w-full text-sm text-gray-700" />
        <button type="submit" class="py-2 px-3 rounded bg-gray-700 text-white hover:bg-gray-800">Upload</button>
      </form>
      <p id="updateFsStatus" class="text-xs text-gray-600 mt-2"></p>

      <div class="mt-6 bg-gray-50 border border-gray-200 rounded-xl p-4">
        <h2 class="text-xl font-semibold mb-2">Fleet registration</h2>
        <p class="text-sm text-gray-600">Register this device with fleet management.</p>
        <button id="registerBtn" class="mt-3 py-2 px-3 rounded bg-green-600 text-white hover:bg-green-700">üîó Register device</button>
        <p id="registerStatus" class="text-xs text-gray-600 mt-2"></p>
        <pre id="registerResponse" class="text-xs text-gray-700 bg-white border border-gray-200 rounded p-2 mt-2 hidden whitespace-pre-wrap"></pre>
      </div>

      <div class="mt-6 bg-gray-50 border border-gray-200 rounded-xl p-4">
        <h2 class="text-xl font-semibold mb-2">Build info</h2>
        <dl class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
          <dt class="text-gray-500">Firmware</dt>
          <dd id="buildFirmware" class="text-gray-800">-</dd>
          <dt class="text-gray-500">UI</dt>
          <dd id="buildUi" class="text-gray-800">-</dd>
          <dt class="text-gray-500">Git SHA</dt>
          <dd id="buildSha" class="text-gray-800">-</dd>
          <dt class="text-gray-500">Git Branch</dt>
          <dd id="buildBranch" class="text-gray-800">-</dd>
          <dt class="text-gray-500">Build time (UTC)</dt>
          <dd id="buildTime" class="text-gray-800">-</dd>
          <dt class="text-gray-500">Environment</dt>
          <dd id="buildEnv" class="text-gray-800">-</dd>
          <dt class="text-gray-500">Device ID</dt>
          <dd id="buildDeviceId" class="text-gray-800">-</dd>
          <dt class="text-gray-500">Hardware ID</dt>
          <dd id="buildHardwareId" class="text-gray-800">-</dd>
        </dl>
        <p id="buildInfoStatus" class="text-xs text-gray-500 mt-2"></p>
      </div>
    </section>
  </div>

  <script>
    const formatVariantLabel = (variant) => {
      if (!variant) return '';
      const base = variant.label || variant.key || '';
      const lang = variant.language ? variant.language.toUpperCase() : '';
      const ver = variant.version ? variant.version.toUpperCase() : '';
      const suffix = [lang, ver].filter(Boolean).join(' ');
      return suffix ? `${base} [${suffix}]` : base;
    };

    // Update via OTA
    const updateBtn = document.getElementById('updateBtnAdm');
    const updateStatusEl = document.getElementById('updateStatus');
    const updateBtnMsg = document.getElementById('updateBtnMsg');
    const updateSpinnerAdm = document.getElementById('updateSpinnerAdm');
    if (updateBtn) {
      const fetchWithTimeout = async (url, options = {}, timeoutMs = 5000) => {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeoutMs);
        try {
          const res = await fetch(url, { ...options, signal: controller.signal, cache: 'no-store' });
          return res;
        } finally {
          clearTimeout(id);
        }
      };
      const getDeviceInfo = async () => {
        const res = await fetchWithTimeout('/api/device/info');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return res.json();
      };
      const getVersion = async () => {
        const res = await fetchWithTimeout('/version');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return res.text();
      };
      const waitForUpdateCompletion = async (preUptime, preVersion) => {
        const start = Date.now();
        const maxMs = 180000;
        let sawOffline = false;
        while (Date.now() - start < maxMs) {
          await new Promise((resolve) => setTimeout(resolve, 3000));
          try {
            const res = await fetchWithTimeout('/api/update/status');
            if (!res.ok) throw new Error('HTTP ' + res.status);
            const body = await res.json();
            if (body.running) {
              continue;
            }
            let uptime = null;
            let version = null;
            try {
              const info = await getDeviceInfo();
              uptime = info.uptime_ms;
            } catch (e) {
            }
            try {
              version = await getVersion();
            } catch (e) {
            }
            if (preUptime !== null && uptime !== null && uptime < preUptime) {
              return 'reboot';
            }
            if (preVersion && version && version.trim() !== preVersion.trim()) {
              return 'version';
            }
            if (sawOffline) {
              return 'reboot';
            }
            return 'no-update';
          } catch (e) {
            sawOffline = true;
          }
        }
        return 'timeout';
      };
      updateBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        if (!confirm('Check for firmware updates and start OTA?')) return;
        if (updateStatusEl) updateStatusEl.textContent = 'Checking for updates‚Ä¶';
        if (updateBtnMsg) updateBtnMsg.textContent = 'Checking‚Ä¶';
        if (updateSpinnerAdm) updateSpinnerAdm.classList.remove('hidden');
        updateBtn.disabled = true;
        updateBtn.classList.add('opacity-50', 'cursor-not-allowed');
        try {
          let preUptime = null;
          let preVersion = null;
          try {
            const info = await getDeviceInfo();
            preUptime = info.uptime_ms;
          } catch (e) {
          }
          try {
            preVersion = await getVersion();
          } catch (e) {
          }
          const r = await fetch('/checkForUpdate');
          if (r.ok) {
            if (updateStatusEl) updateStatusEl.textContent = 'Update started. Device will reboot shortly‚Ä¶';
            if (updateBtnMsg) updateBtnMsg.textContent = 'Running‚Ä¶';
            const result = await waitForUpdateCompletion(preUptime, preVersion);
            if (result === 'reboot' || result === 'version') {
              location.reload();
              return;
            }
            if (result === 'no-update') {
              if (updateStatusEl) updateStatusEl.textContent = 'No update applied.';
            } else {
              if (updateStatusEl) updateStatusEl.textContent = 'Update may still be running.';
            }
            if (updateSpinnerAdm) updateSpinnerAdm.classList.add('hidden');
          } else {
            const msg = 'Update failed (HTTP ' + r.status + ')';
            if (updateStatusEl) updateStatusEl.textContent = msg;
            if (updateBtnMsg) updateBtnMsg.textContent = msg;
            if (updateSpinnerAdm) updateSpinnerAdm.classList.add('hidden');
          }
        } catch (err) {
          if (updateStatusEl) updateStatusEl.textContent = 'Update request failed';
          if (updateBtnMsg) updateBtnMsg.textContent = 'Request failed';
          if (updateSpinnerAdm) updateSpinnerAdm.classList.add('hidden');
        } finally {
          updateBtn.disabled = false;
          updateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        }
      });
    }

    const channelRadiosAdmin = document.querySelectorAll('input[name="updateChannelAdmin"]');
    const channelStatusAdmin = document.getElementById('updateChannelStatusAdmin');
    let lastAdminChannel = 'stable';
    const applyChannelGuardAdmin = (ch) => {
      if (channelStatusAdmin) {
        channelStatusAdmin.textContent = `Current channel: ${ch}${ch === 'develop' ? ' (automatic updates disabled)' : ''}`;
      }
    };
    const loadChannelAdmin = async () => {
      if (channelStatusAdmin) channelStatusAdmin.textContent = 'Loading channel‚Ä¶';
      try {
        const res = await fetch('/api/update/channel');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const body = await res.json();
        const ch = (body && body.channel) ? body.channel : 'stable';
        lastAdminChannel = ch;
        channelRadiosAdmin.forEach(r => { r.checked = (r.value === ch); });
        applyChannelGuardAdmin(ch);
      } catch (err) {
        channelRadiosAdmin.forEach(r => { if (r.value === 'stable') r.checked = true; });
        lastAdminChannel = 'stable';
        applyChannelGuardAdmin('stable');
      }
    };
    if (channelRadiosAdmin.length) {
      loadChannelAdmin();
      channelRadiosAdmin.forEach(r => {
        r.addEventListener('change', async () => {
          if (!r.checked) return;
          const ch = r.value;
          if (ch === 'develop') {
            const ok = window.confirm('Weet je zeker dat je het ontwikkelkanaal wilt gebruiken? Dit kan de klok onbruikbaar maken en herstel is niet gegarandeerd.');
            if (!ok) {
              r.checked = false;
              const prev = Array.from(channelRadiosAdmin).find(x => x.value === lastAdminChannel);
              if (prev) prev.checked = true;
              applyChannelGuardAdmin(lastAdminChannel);
              return;
            }
          }
          if (channelStatusAdmin) channelStatusAdmin.textContent = 'Saving‚Ä¶';
          try {
            const res = await fetch('/api/update/channel', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ channel: ch })
            });
            if (!res.ok) throw new Error('HTTP ' + res.status);
            lastAdminChannel = ch;
            applyChannelGuardAdmin(ch);
          } catch (err) {
            if (channelStatusAdmin) channelStatusAdmin.textContent = 'Save failed; keeping previous value';
            channelRadiosAdmin.forEach(radio => { radio.checked = (radio.value === lastAdminChannel); });
            applyChannelGuardAdmin(lastAdminChannel);
          }
        });
      });
    }

    // Init verkooptijd toggle
    const sell = document.getElementById('sellMode');
    fetch('/getSellMode').then(r => r.text()).then(v => {
      if (sell) sell.checked = (v.trim() === 'on');
    });
    sell.addEventListener('change', () => {
      fetch(`/setSellMode?state=${sell.checked ? 'on' : 'off'}`)
        .then(() => {
          // no-op; device display updates immediately
        });
    });

    // Grid variant selection
    const gridSelect = document.getElementById('gridVariant');
    const gridStatus = document.getElementById('gridVariantStatus');
    const loadGridVariants = async () => {
      if (!gridSelect) return;
      try {
        const res = await fetch('/listGridVariants');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const variants = await res.json();
        gridSelect.innerHTML = '';
        variants.forEach((v) => {
          const opt = document.createElement('option');
          opt.value = v.id;
          opt.textContent = formatVariantLabel(v);
          if (v.active) opt.selected = true;
          gridSelect.appendChild(opt);
        });
        if (gridStatus) {
          const active = variants.find(v => v.active);
          gridStatus.textContent = active ? `Actieve grid: ${formatVariantLabel(active)}` : '';
        }
      } catch (err) {
        if (gridStatus) gridStatus.textContent = 'Kon grid-varianten niet laden';
      }
    };
    if (gridSelect) {
      loadGridVariants();
      gridSelect.addEventListener('change', async () => {
        const id = gridSelect.value;
        if (gridStatus) gridStatus.textContent = 'Bezig met opslaan‚Ä¶';
        try {
          const res = await fetch(`/setGridVariant?id=${encodeURIComponent(id)}`);
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const body = await res.json();
          if (gridStatus) gridStatus.textContent = `Actieve grid: ${formatVariantLabel(body)}`;
        } catch (err) {
          if (gridStatus) gridStatus.textContent = 'Opslaan mislukt';
        }
      });
    }

    const syncBtn = document.getElementById('syncUiBtn');
    const syncMsg = document.getElementById('syncUiMsg');
    if (syncBtn) {
      syncBtn.addEventListener('click', async () => {
        if (!confirm('Sync UI files from manifest? This may take a moment.')) return;
        if (syncMsg) syncMsg.textContent = 'Sync in progress‚Ä¶';
        try {
          const res = await fetch('/syncUI', { method: 'POST' });
          if (res.ok) {
            if (syncMsg) syncMsg.textContent = 'UI sync triggered. Check logs for progress.';
          } else {
            if (syncMsg) syncMsg.textContent = 'UI sync failed (HTTP ' + res.status + ')';
          }
        } catch (err) {
          if (syncMsg) syncMsg.textContent = 'UI sync request failed';
        }
      });
    }

    // Init admin color picker
    const acp = document.getElementById('adminColorPicker');
    if (acp) {
      fetch('/getColor').then(r => r.text()).then(hex => {
        if (hex && hex.length === 6) acp.value = '#' + hex;
      });
      acp.addEventListener('input', (e) => {
        const hex = e.target.value.substring(1);
        fetch(`/setColor?color=${hex}`);
      });
    }

    // Factory reset
    const fbtn = document.getElementById('factoryBtn');
    const fmsg = document.getElementById('factoryMsg');
    if (fbtn) {
      fbtn.addEventListener('click', async () => {
        if (!confirm('Are you sure you want to perform a full factory reset?')) return;
        const r = await fetch('/factoryreset', { method: 'POST' });
        if (r.ok) {
          if (fmsg) fmsg.textContent = 'Factory reset started. Device will reboot shortly...';
          setTimeout(() => location.reload(), 10000);
        } else {
          if (fmsg) fmsg.textContent = 'Failed to start factory reset';
        }
      });
    }

    const buildStatus = document.getElementById('buildInfoStatus');
    async function loadBuildInfo() {
      try {
        const [res, devRes] = await Promise.all([
          fetch('/buildinfo'),
          fetch('/api/device/info')
        ]);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const info = await res.json();
        let devInfo = {};
        if (devRes.ok) {
          devInfo = await devRes.json();
        }
        const set = (id, val) => {
          const el = document.getElementById(id);
          if (el) el.textContent = val || '-';
        };
        set('buildFirmware', info.firmware);
        set('buildUi', info.ui);
        set('buildSha', info.git_sha);
        set('buildBranch', info.git_branch);
        set('buildTime', info.build_time_utc);
        set('buildEnv', info.environment);
        set('buildDeviceId', devInfo.device_id);
        set('buildHardwareId', devInfo.hardware_id);
        const syncSection = document.getElementById('syncUiSection');
        const channelSection = document.getElementById('releaseChannelSection');
        const updateBtn = document.getElementById('updateBtnAdm');
        const updatePageLink = document.getElementById('updatePageLink');
        if (syncSection && info.ui_sync_supported === false) {
          syncSection.classList.add('hidden');
        }
        if (info.ota_enabled === false) {
          if (syncSection) syncSection.classList.add('hidden');
          if (channelSection) channelSection.classList.add('hidden');
          if (updateBtn) updateBtn.classList.add('hidden');
          if (updatePageLink) updatePageLink.classList.add('hidden');
        }
        if (buildStatus) buildStatus.textContent = 'Last updated just now.';
      } catch (err) {
        if (buildStatus) buildStatus.textContent = 'Failed to load build info (' + err.message + ')';
      }
    }
    loadBuildInfo();

    // Log Settings
    const logRetention = document.getElementById('logRetention');
    const logRetentionVal = document.getElementById('logRetentionVal');
    const logDeleteOnBoot = document.getElementById('logDeleteOnBoot');
    const logLevel = document.getElementById('logLevel');
    const saveLogSettings = document.getElementById('saveLogSettings');
    const logSettingsStatus = document.getElementById('logSettingsStatus');

    if (logRetention) {
      logRetention.addEventListener('input', () => {
        logRetentionVal.textContent = logRetention.value;
      });
    }

    async function loadLogSettings() {
      try {
        const res = await fetch('/api/logs/settings');
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const settings = await res.json();
        if (logRetention) {
          logRetention.value = settings.retention_days;
          logRetentionVal.textContent = settings.retention_days;
        }
        if (logDeleteOnBoot) {
          logDeleteOnBoot.checked = settings.delete_on_boot;
        }
        if (logLevel) {
          logLevel.value = settings.level;
        }
      } catch (err) {
      }
    }

    if (saveLogSettings) {
      saveLogSettings.addEventListener('click', async () => {
        const days = logRetention.value;
        const delOnBoot = logDeleteOnBoot.checked;
        const level = logLevel.value;
        
        logSettingsStatus.textContent = 'Saving...';
        logSettingsStatus.className = 'text-xs text-center mt-2 text-gray-600';
        
        try {
          const res = await fetch(`/api/logs/settings?retention_days=${days}&delete_on_boot=${delOnBoot}&level=${level}`, {
            method: 'POST'
          });
          if (res.ok) {
            logSettingsStatus.textContent = 'Settings saved successfully';
            logSettingsStatus.className = 'text-xs text-center mt-2 text-green-600';
          } else {
            throw new Error('HTTP ' + res.status);
          }
        } catch (err) {
          logSettingsStatus.textContent = 'Save failed: ' + err.message;
          logSettingsStatus.className = 'text-xs text-center mt-2 text-red-600';
        }
      });
    }

    loadLogSettings();

    const registerBtn = document.getElementById('registerBtn');
    const registerStatus = document.getElementById('registerStatus');
    const registerResponse = document.getElementById('registerResponse');
    if (registerBtn) {
      registerBtn.addEventListener('click', async () => {
        registerBtn.disabled = true;
        registerBtn.classList.add('opacity-50', 'cursor-not-allowed');
        if (registerStatus) registerStatus.textContent = 'Registering device...';
        if (registerResponse) {
          registerResponse.textContent = '';
          registerResponse.classList.add('hidden');
        }
        try {
          const res = await fetch('/api/device/register', { method: 'POST' });
          const text = await res.text();
          let body = text;
          try {
            const parsed = JSON.parse(text);
            body = JSON.stringify(parsed, null, 2);
          } catch (err) {
          }
          if (registerResponse) {
            registerResponse.textContent = body || '(empty response)';
            registerResponse.classList.remove('hidden');
          }
          if (registerStatus) {
            registerStatus.textContent = res.ok
              ? 'Registration succeeded.'
              : 'Registration failed (HTTP ' + res.status + ').';
          }
        } catch (err) {
          if (registerStatus) registerStatus.textContent = 'Registration request failed.';
          if (registerResponse) {
            registerResponse.textContent = err && err.message ? err.message : String(err);
            registerResponse.classList.remove('hidden');
          }
        } finally {
          registerBtn.disabled = false;
          registerBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        }
      });
    }
  </script>
</body>
</html>
